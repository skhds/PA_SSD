Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .bottleneck_metrics.cc.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .bottleneck_metrics.h.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .BTN_dIssueTime.h.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .BTN_dIssueTIme.h.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .BTN_waitingTime.h.swp
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .BTN_waitingTime.h.un~
diff /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/buffer_ctrl.h ./buffer_ctrl.h
12,13c12,13
< #define READ_Q_SIZE 32
< #define WRITE_Q_SIZE 32
---
> #define READ_Q_SIZE 5
> #define WRITE_Q_SIZE 5
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .buffer_ctrl.h.un~
Common subdirectories: /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/cwr and ./cwr
Only in ./: diff
diff /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/global_flag.h ./global_flag.h
10c10
< #define CMD_BUS_TOTAL_BW 1.6  //400MHz - 32bit
---
> #define CMD_BUS_TOTAL_BW 1.6 //400MHz - 32bit
15,16c15,16
< #define HOSTIF_DEBUG 0 
< #define DEVIF_DEBUG 0
---
> #define HOSTIF_DEBUG 1 
> #define DEVIF_DEBUG 1
42a43
> 
Binary files /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/.global_flag.h.un~ and ./.global_flag.h.un~ differ
diff /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/IF_Spec.h ./IF_Spec.h
6,7c6,7
< #define CLOCK_PERIOD        2.5           // 200Mhz
< #define IF_BANDWIDTH        (768)  //768MB/s(6Gbps) : SATA 3
---
> #define CLOCK_PERIOD        5           // 200Mhz
> #define IF_BANDWIDTH        (600)  //768MB/s (6Gbps) : SATA 3
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .IF_Spec.h.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .NAND_Ctrl_Spec.h.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .NAND_MAN_Spec.h.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .NAND_Spec.h.swp
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .NAND_Spec.h.un~
diff /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/NAND_Struct.h ./NAND_Struct.h
87,91c87,91
<     NAND_CMD_SET opCode;
<     unsigned int iAddr1;
<     unsigned int iAddr2;
<     unsigned int iAddr3;
<     unsigned int iAddr4;
---
>     NAND_CMD_SET opCode; 
>     unsigned int iAddr1; //PBA
>     unsigned int iAddr2; //nothing
>     unsigned int iAddr3; //LBA
>     unsigned int iAddr4; //len
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .NAND_Struct.h.un~
diff /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/ssd_struct.h ./ssd_struct.h
61c61
<     uint Addr;
---
>     uint Addr; //DRAM addr
63,64c63,64
<     uint Len;
<     uint lba;
---
>     uint Len; 
>     uint lba; //LBA
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .ssd_struct.h.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .stats.h.un~
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .SubReq_def.h.un~
Common subdirectories: /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/.svn and ./.svn
diff /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/tags ./tags
7a8
> ACTIVE	BTN_waitingTime.h	/^            ACTIVE$/;"	e	enum:BTN_Analysis::eWaitingState
19c20
< BIT_FOR_BLOCK	NAND_Ctrl_Spec.h	/^const int BIT_FOR_BLOCK = BIT_FOR_PAGE + PAGE_PER_BLOCK_BIT; \/\/16$/;"	v
---
> BIT_FOR_BLOCK	NAND_Ctrl_Spec.h	/^const int BIT_FOR_BLOCK = BIT_FOR_PAGE + PAGE_PER_BLOCK_BIT; \/\/15$/;"	v
26c27
< BIT_FOR_CHANNEL	NAND_Ctrl_Spec.h	/^const int BIT_FOR_CHANNEL = SECTOR_PER_PAGE_BIT;       \/\/4$/;"	v
---
> BIT_FOR_CHANNEL	NAND_Ctrl_Spec.h	/^const int BIT_FOR_CHANNEL = SECTOR_PER_PAGE_BIT;       \/\/5$/;"	v
31c32
< BIT_FOR_PAGE	NAND_Ctrl_Spec.h	/^const int BIT_FOR_PAGE = BIT_FOR_WAY + WAY_PER_CHANNEL_BIT; \/\/10$/;"	v
---
> BIT_FOR_PAGE	NAND_Ctrl_Spec.h	/^const int BIT_FOR_PAGE = BIT_FOR_WAY + WAY_PER_CHANNEL_BIT; \/\/9$/;"	v
48a50,51
> BTN_Analysis	BTN_waitingTime.h	/^    namespace BTN_Analysis{$/;"	n
> BTN_DISSUETIME_H__	trackByID_node.h	2;"	d
50a54
> BUSY_WAITING	BTN_waitingTime.h	/^            BUSY_WAITING,$/;"	e	enum:BTN_Analysis::eWaitingState
60,62c64,67
< CHANNEL_PER_SSD_BIT	NAND_Ctrl_Spec.h	/^const int CHANNEL_PER_SSD_BIT = 1;$/;"	v
< CHANNEL_PER_SSD_BIT	NAND_MAN_Spec.h	/^const int CHANNEL_PER_SSD_BIT = 1;$/;"	v
< CHANNEL_PER_SSD_BIT	NAND_Spec.h	/^const int CHANNEL_PER_SSD_BIT = 3;$/;"	v
---
> CACHE_DATA_REGION_OFFSET	buffer_ctrl.h	7;"	d
> CHANNEL_PER_SSD_BIT	NAND_Ctrl_Spec.h	/^const int CHANNEL_PER_SSD_BIT = 2;$/;"	v
> CHANNEL_PER_SSD_BIT	NAND_MAN_Spec.h	/^const int CHANNEL_PER_SSD_BIT = 2;$/;"	v
> CHANNEL_PER_SSD_BIT	NAND_Spec.h	/^const int CHANNEL_PER_SSD_BIT = 2;$/;"	v
65a71,75
> CMD_BUS_TIME_CONSUMED	global_flag.h	/^double CMD_BUS_TIME_CONSUMED[3] = {0};$/;"	v
> CMD_BUS_TOTAL_BW	global_flag.h	10;"	d
> CMD_OP	trackByID_node.h	/^        enum CMD_OP{$/;"	g	namespace:SSDmetric
> CMD_READ	trackByID_node.h	/^          CMD_READ = 1$/;"	e	enum:SSDmetric::CMD_OP
> CMD_WRITE	trackByID_node.h	/^          CMD_WRITE = 0,$/;"	e	enum:SSDmetric::CMD_OP
67a78
> CPU_SIDE_CALLBACK_OFFSET	buffer_ctrl.h	6;"	d
78,80c89,94
< DATA_PAGE_SIZE	NAND_Ctrl_Spec.h	/^const int DATA_PAGE_SIZE = 8192;$/;"	v
< DATA_PAGE_SIZE	NAND_MAN_Spec.h	/^const int DATA_PAGE_SIZE = 8192;$/;"	v
< DATA_PAGE_SIZE	NAND_Spec.h	/^const int DATA_PAGE_SIZE = 8192;$/;"	v
---
> DATA_BUS_TIME_CONSUMED	global_flag.h	/^double DATA_BUS_TIME_CONSUMED[3] = {0};$/;"	v
> DATA_BUS_TOTAL_BW	global_flag.h	11;"	d
> DATA_PAGE_SIZE	NAND_Ctrl_Spec.h	/^const int DATA_PAGE_SIZE = 16384;$/;"	v
> DATA_PAGE_SIZE	NAND_MAN_Spec.h	/^const int DATA_PAGE_SIZE = 16384;$/;"	v
> DATA_PAGE_SIZE	NAND_Spec.h	/^const int DATA_PAGE_SIZE = 16384;$/;"	v
> DEVIF_DEBUG	global_flag.h	16;"	d
83a98,99
> DEV_IF	BTN_waitingTime.h	/^            DEV_IF,$/;"	e	enum:BTN_Analysis::eModuleType
> DEV_IF	trackByID_node.h	/^            DEV_IF = 1,$/;"	e	enum:SSDmetric::eModuleType
84a101
> DRAM_DEBUG	global_flag.h	18;"	d
86a104
> DRAM_STATS	global_flag.h	/^long long int DRAM_STATS[2][2] = {0}; \/\/2 : Cache Buffer\/Metadata, 2: Write\/Read$/;"	v
87a106,107
> DRAM_ctrl	BTN_waitingTime.h	/^            DRAM_ctrl,$/;"	e	enum:BTN_Analysis::eModuleType
> DRAM_ctrl	trackByID_node.h	/^            DRAM_ctrl = 3,$/;"	e	enum:SSDmetric::eModuleType
90a111,113
> HOSTIF_DEBUG	global_flag.h	15;"	d
> HOST_IF	BTN_waitingTime.h	/^            HOST_IF,$/;"	e	enum:BTN_Analysis::eModuleType
> HOST_IF	trackByID_node.h	/^            HOST_IF = 0,$/;"	e	enum:SSDmetric::eModuleType
93a117
> HOST_SIDE_CALLBACK_OFFSET	buffer_ctrl.h	9;"	d
94a119,121
> IDEnd	trackByID_node.h	/^                void IDEnd(){$/;"	f	class:SSDmetric::nodeReqID
> IDFinish	trackByID.h	/^    void trackByID::IDFinish(int id){$/;"	f	class:SSDmetric::trackByID
> IDLE	BTN_waitingTime.h	/^            IDLE,$/;"	e	enum:BTN_Analysis::eWaitingState
120,125c147,152
< MapTable_Copyback	NAND_Struct.h	/^    MapTable_Copyback   = 11,$/;"	e	enum:NAND_CMD_SET
< MapTable_Copyback_Pgm	NAND_Struct.h	/^    MapTable_Copyback_Pgm = 12,$/;"	e	enum:NAND_CMD_SET
< MapTable_Copyback_Rd	NAND_Struct.h	/^    MapTable_Copyback_Rd = 13,$/;"	e	enum:NAND_CMD_SET
< MapTable_Erase	NAND_Struct.h	/^    MapTable_Erase = 14,$/;"	e	enum:NAND_CMD_SET
< MapTable_Program	NAND_Struct.h	/^    MapTable_Program    = 10,$/;"	e	enum:NAND_CMD_SET
< MapTable_Read	NAND_Struct.h	/^    MapTable_Read       = 9, \/\/ iAddr1: nand \/\/ iAddr2: memory \/\/ iAddr3: offset (byte) \/\/ iAddr4: length (byte)$/;"	e	enum:NAND_CMD_SET
---
> MapTable_Copyback	NAND_Struct.h	/^    MapTable_Copyback   = 9,$/;"	e	enum:NAND_CMD_SET
> MapTable_Copyback_Pgm	NAND_Struct.h	/^    MapTable_Copyback_Pgm = 10,$/;"	e	enum:NAND_CMD_SET
> MapTable_Copyback_Rd	NAND_Struct.h	/^    MapTable_Copyback_Rd = 11,$/;"	e	enum:NAND_CMD_SET
> MapTable_Erase	NAND_Struct.h	/^    MapTable_Erase = 12,$/;"	e	enum:NAND_CMD_SET
> MapTable_Program	NAND_Struct.h	/^    MapTable_Program    = 8,$/;"	e	enum:NAND_CMD_SET
> MapTable_Read	NAND_Struct.h	/^    MapTable_Read       = 7, \/\/ iAddr1: nand \/\/ iAddr2: memory \/\/ iAddr3: offset (byte) \/\/ iAddr4: length (byte)$/;"	e	enum:NAND_CMD_SET
126a154
> NANDCtrl_DEBUG	global_flag.h	20;"	d
141c169,170
< NAND_DATA_BUFFER_MAX_SIZE	NAND_Spec.h	/^const int NAND_DATA_BUFFER_MAX_SIZE = 10*DATA_PAGE_SIZE;$/;"	v
---
> NAND_DATA_BUFFER_MAX_SIZE	NAND_Spec.h	/^const int NAND_DATA_BUFFER_MAX_SIZE = 20*DATA_PAGE_SIZE;$/;"	v
> NAND_DEBUG	global_flag.h	19;"	d
144a174,177
> NAND_Manager	BTN_waitingTime.h	/^            NAND_Manager,$/;"	e	enum:BTN_Analysis::eModuleType
> NAND_Manager	trackByID_node.h	/^            NAND_Manager = 4,$/;"	e	enum:SSDmetric::eModuleType
> NAND_SIDE_CALLBACK_OFFSET	buffer_ctrl.h	10;"	d
> NAND_STATS	global_flag.h	/^long long int NAND_STATS[13][4][4][1024] = {0}; \/\/12 : # of nand opcodes, 4 : # channel, 4 : # way, 1024 : # of blocks$/;"	v
152a186,187
> NUM_MODULES	BTN_waitingTime.h	/^            NUM_MODULES$/;"	e	enum:BTN_Analysis::eModuleType
> NUM_MODULES	trackByID_node.h	/^            NUM_MODULES = 5$/;"	e	enum:SSDmetric::eModuleType
156,159c191,194
< NUM_OF_CHANNEL	NAND_Ctrl_Spec.h	/^const int NUM_OF_CHANNEL = 1;$/;"	v
< NUM_OF_CHANNEL	NAND_MAN_Spec.h	/^const int NUM_OF_CHANNEL = 1;$/;"	v
< NUM_OF_CHANNEL	NAND_Spec.h	/^const int NUM_OF_CHANNEL = 1;$/;"	v
< NUM_OF_CORE	global_flag.h	4;"	d
---
> NUM_OF_CHANNEL	NAND_Ctrl_Spec.h	/^const int NUM_OF_CHANNEL = 4;$/;"	v
> NUM_OF_CHANNEL	NAND_MAN_Spec.h	/^const int NUM_OF_CHANNEL = 4;$/;"	v
> NUM_OF_CHANNEL	NAND_Spec.h	/^const int NUM_OF_CHANNEL = 4;$/;"	v
> NUM_OF_CORE	global_flag.h	8;"	d
163,165c198,200
< NUM_OF_WAY	NAND_Ctrl_Spec.h	/^const int NUM_OF_WAY = 1; $/;"	v
< NUM_OF_WAY	NAND_MAN_Spec.h	/^const int NUM_OF_WAY = 1; $/;"	v
< NUM_OF_WAY	NAND_Spec.h	/^const int NUM_OF_WAY = 1; $/;"	v
---
> NUM_OF_WAY	NAND_Ctrl_Spec.h	/^const int NUM_OF_WAY = 4; $/;"	v
> NUM_OF_WAY	NAND_MAN_Spec.h	/^const int NUM_OF_WAY = 4; $/;"	v
> NUM_OF_WAY	NAND_Spec.h	/^const int NUM_OF_WAY = 4; $/;"	v
179a215,216
> READ_Q_LIMIT_FACTOR	buffer_ctrl.h	15;"	d
> READ_Q_SIZE	buffer_ctrl.h	12;"	d
182,183d218
< RNM_Program	NAND_Struct.h	/^    RNM_Program         = 8,$/;"	e	enum:NAND_CMD_SET
< RNM_Read	NAND_Struct.h	/^    RNM_Read            = 7,$/;"	e	enum:NAND_CMD_SET
190,192c225,227
< SECTOR_PER_PAGE_BIT	NAND_Ctrl_Spec.h	/^const int SECTOR_PER_PAGE_BIT = 4;$/;"	v
< SECTOR_PER_PAGE_BIT	NAND_MAN_Spec.h	/^const int SECTOR_PER_PAGE_BIT = 4;$/;"	v
< SECTOR_PER_PAGE_BIT	NAND_Spec.h	/^const int SECTOR_PER_PAGE_BIT = 4;$/;"	v
---
> SECTOR_PER_PAGE_BIT	NAND_Ctrl_Spec.h	/^const int SECTOR_PER_PAGE_BIT = 5;$/;"	v
> SECTOR_PER_PAGE_BIT	NAND_MAN_Spec.h	/^const int SECTOR_PER_PAGE_BIT = 5;$/;"	v
> SECTOR_PER_PAGE_BIT	NAND_Spec.h	/^const int SECTOR_PER_PAGE_BIT = 5;$/;"	v
193a229,232
> SECTOR_SIZE_BYTE	buffer_ctrl.h	18;"	d
> SOFTWARE_FLAG	global_flag.h	/^bool SOFTWARE_FLAG = false;$/;"	v
> SOFTWARE_TIME	global_flag.h	/^double SOFTWARE_TIME[2] = {0};$/;"	v
> SOFTWARE_count	global_flag.h	/^long long int SOFTWARE_count = 0;$/;"	v
197a237,240
> SSDmetric	trackByID.h	/^namespace SSDmetric{$/;"	n
> SSDmetric	trackByID_node.h	/^    namespace SSDmetric{$/;"	n
> SUB_DEBUG	global_flag.h	17;"	d
> SWtime_prev	global_flag.h	/^static double SWtime_prev = 0;$/;"	v
198a242,244
> SubList	trackByID_node.h	/^                std::vector<nodeSubReq> SubList;$/;"	m	class:SSDmetric::nodeReqID
> SubReqMan	BTN_waitingTime.h	/^            SubReqMan,$/;"	e	enum:BTN_Analysis::eModuleType
> SubReqMan	trackByID_node.h	/^            SubReqMan = 2,$/;"	e	enum:SSDmetric::eModuleType
203,211c249,258
< T_BER	NAND_Ctrl_Spec.h	/^    T_BER = 5000000$/;"	e	enum:NAND_TIMING
< T_BER	NAND_MAN_Spec.h	/^    T_BER = 2000000$/;"	e	enum:NAND_TIMING
< T_BER	NAND_Spec.h	/^    T_BER = 5000000$/;"	e	enum:NAND_TIMING
< T_PROG	NAND_Ctrl_Spec.h	/^    T_PROG = 300000,$/;"	e	enum:NAND_TIMING
< T_PROG	NAND_MAN_Spec.h	/^    T_PROG = 300000,$/;"	e	enum:NAND_TIMING
< T_PROG	NAND_Spec.h	/^    T_PROG = 300000,$/;"	e	enum:NAND_TIMING
< T_R	NAND_Ctrl_Spec.h	/^    T_R = 75000,$/;"	e	enum:NAND_TIMING
< T_R	NAND_MAN_Spec.h	/^    T_R = 25000,$/;"	e	enum:NAND_TIMING
< T_R	NAND_Spec.h	/^    T_R = 75000,$/;"	e	enum:NAND_TIMING
---
> TRANSFER	BTN_waitingTime.h	/^            TRANSFER,$/;"	e	enum:BTN_Analysis::eWaitingState
> T_BER	NAND_Ctrl_Spec.h	/^    T_BER = 3500000$/;"	e	enum:NAND_TIMING
> T_BER	NAND_MAN_Spec.h	/^    T_BER = 3500000$/;"	e	enum:NAND_TIMING
> T_BER	NAND_Spec.h	/^    T_BER = 3500000$/;"	e	enum:NAND_TIMING
> T_PROG	NAND_Ctrl_Spec.h	/^    T_PROG = 660000,$/;"	e	enum:NAND_TIMING
> T_PROG	NAND_MAN_Spec.h	/^    T_PROG = 660000,$/;"	e	enum:NAND_TIMING
> T_PROG	NAND_Spec.h	/^    T_PROG = 660000,$/;"	e	enum:NAND_TIMING
> T_R	NAND_Ctrl_Spec.h	/^    T_R = 45000,$/;"	e	enum:NAND_TIMING
> T_R	NAND_MAN_Spec.h	/^    T_R = 45000,$/;"	e	enum:NAND_TIMING
> T_R	NAND_Spec.h	/^    T_R = 45000,$/;"	e	enum:NAND_TIMING
213c260
< UNIT_OF_REQUEST	ssd_struct.h	132;"	d
---
> UNIT_OF_REQUEST	ssd_struct.h	136;"	d
216,218c263,265
< WAY_PER_CHANNEL_BIT	NAND_Ctrl_Spec.h	/^const int WAY_PER_CHANNEL_BIT = 1;$/;"	v
< WAY_PER_CHANNEL_BIT	NAND_MAN_Spec.h	/^const int WAY_PER_CHANNEL_BIT = 1;$/;"	v
< WAY_PER_CHANNEL_BIT	NAND_Spec.h	/^const int WAY_PER_CHANNEL_BIT = 3;$/;"	v
---
> WAY_PER_CHANNEL_BIT	NAND_Ctrl_Spec.h	/^const int WAY_PER_CHANNEL_BIT = 2;$/;"	v
> WAY_PER_CHANNEL_BIT	NAND_MAN_Spec.h	/^const int WAY_PER_CHANNEL_BIT = 2;$/;"	v
> WAY_PER_CHANNEL_BIT	NAND_Spec.h	/^const int WAY_PER_CHANNEL_BIT = 2;$/;"	v
221a269,270
> WRITE_Q_LIMIT_FACTOR	buffer_ctrl.h	16;"	d
> WRITE_Q_SIZE	buffer_ctrl.h	13;"	d
224,226c273,282
< _ADDR_CPU2_BASE_	NAND_Struct.h	7;"	d
< _ADDR_DATA_DRAM_	NAND_Struct.h	18;"	d
< _ADDR_DRAM_STATEINFORM_	NAND_Struct.h	6;"	d
---
> _ADDR_CPU2_BASE_	NAND_Struct.h	37;"	d
> _ADDR_DATA_DRAM_	NAND_Struct.h	25;"	d
> _ADDR_DATA_SUBM_	NAND_Struct.h	26;"	d
> _ADDR_DEVIF_BASE_	NAND_Struct.h	12;"	d
> _ADDR_DRAM_BASE_	NAND_Struct.h	16;"	d
> _ADDR_DRAM_STATEINFORM_	NAND_Struct.h	36;"	d
> _ADDR_IRQ_BASE_	NAND_Struct.h	13;"	d
> _ADDR_MEMCON_BASE_	NAND_Struct.h	14;"	d
> _ADDR_NUMS_BASE_	NAND_Struct.h	11;"	d
> _ADDR_SUB_BASE_	NAND_Struct.h	15;"	d
228c284,286
< _NAND_DATA_BUFFER_MAX_SIZE	NAND_Struct.h	20;"	d
---
> _CMDMASTER_OFFSET_NANDSIDE_	NAND_Struct.h	20;"	d
> _DATAMASTER_OFFSET_NANDSIDE_	NAND_Struct.h	30;"	d
> _NAND_DATA_BUFFER_MAX_SIZE	NAND_Struct.h	51;"	d
233,240c291,298
< _OFFSET_DRAM_ADDR_	NAND_Struct.h	9;"	d
< _OFFSET_DRAM_LENGTH_	NAND_Struct.h	10;"	d
< _OFFSET_DRAM_REQ_ID_	NAND_Struct.h	11;"	d
< _OFFSET_NAND_ADDR1_	NAND_Struct.h	13;"	d
< _OFFSET_NAND_ADDR2_	NAND_Struct.h	14;"	d
< _OFFSET_NAND_ADDR3_	NAND_Struct.h	15;"	d
< _OFFSET_NAND_ADDR4_	NAND_Struct.h	16;"	d
< _OFFSET_NAND_CMD_	NAND_Struct.h	12;"	d
---
> _OFFSET_DRAM_ADDR_	NAND_Struct.h	39;"	d
> _OFFSET_DRAM_LENGTH_	NAND_Struct.h	40;"	d
> _OFFSET_DRAM_REQ_ID_	NAND_Struct.h	41;"	d
> _OFFSET_NAND_ADDR1_	NAND_Struct.h	43;"	d
> _OFFSET_NAND_ADDR2_	NAND_Struct.h	44;"	d
> _OFFSET_NAND_ADDR3_	NAND_Struct.h	45;"	d
> _OFFSET_NAND_ADDR4_	NAND_Struct.h	46;"	d
> _OFFSET_NAND_CMD_	NAND_Struct.h	42;"	d
242a301,302
> __BOTTLENECK_METRIC_H__	BTN_waitingTime.h	2;"	d
> __BUFFER_CTLR_H__	buffer_ctrl.h	2;"	d
245a306,308
> active_time	BTN_waitingTime.h	/^                double active_time;$/;"	m	class:BTN_Analysis::waiting_time
> busy_waiting	BTN_waitingTime.h	/^                double busy_waiting;$/;"	m	class:BTN_Analysis::waiting_time
> change_state	BTN_waitingTime.h	/^        void waiting_time::change_state(eWaitingState cur_state){$/;"	f	class:BTN_Analysis::waiting_time
257a321,324
> done	trackByID.h	/^    void trackByID::done(int id, int lba_offset, int len, eModuleType module, double time){$/;"	f	class:SSDmetric::trackByID
> done	trackByID_node.h	/^                void done(double time){$/;"	f	class:SSDmetric::nodeModule
> done	trackByID_node.h	/^                void done(eModuleType module, double time){$/;"	f	class:SSDmetric::nodeSubReq
> done	trackByID_node.h	/^                void done(int subID, eModuleType module, double time){$/;"	f	class:SSDmetric::nodeReqID
260a328,331
> dumptrace	trackByID_node.h	/^                virtual void dumptrace(ofstream &fp){$/;"	f	class:SSDmetric::nodeModule
> dumptrace	trackByID_node.h	/^                void dumptrace (ofstream &fp){$/;"	f	class:SSDmetric::nodeModuleResp
> dumptrace	trackByID_node.h	/^                void dumptrace(ofstream &fp){$/;"	f	class:SSDmetric::nodeReqID
> dumptrace	trackByID_node.h	/^                void dumptrace(ofstream &fp){$/;"	f	class:SSDmetric::nodeSubReq
262a334,335
> eModuleType	BTN_waitingTime.h	/^        enum eModuleType{$/;"	g	namespace:BTN_Analysis
> eModuleType	trackByID_node.h	/^        enum eModuleType{$/;"	g	namespace:SSDmetric
264a338
> eWaitingState	BTN_waitingTime.h	/^        enum eWaitingState{$/;"	g	namespace:BTN_Analysis
265a340,345
> end	BTN_waitingTime.h	/^        void waiting_time::end(){$/;"	f	class:BTN_Analysis::waiting_time
> end	trackByID_node.h	/^                bool end;$/;"	m	class:SSDmetric::nodeModule
> end	trackByID_node.h	/^                bool end;$/;"	m	class:SSDmetric::nodeReqID
> finishTime	trackByID_node.h	/^                double finishTime;$/;"	m	class:SSDmetric::nodeModule
> fp	trackByID.h	/^            ofstream fp;$/;"	m	class:SSDmetric::trackByID
> g_initialize_end	global_flag.h	/^bool        g_initialize_end = false;$/;"	v
281c361
< iNextSector	SubReq_def.h	/^    uint            iNextSector;        \/\/ indicate the next sector to be handled$/;"	m	struct:sIntReq_t
---
> iNextSector	SubReq_def.h	/^    uint            iNextSector;        \/\/ indicate the next sector to be handled $/;"	m	struct:sIntReq_t
282a363,366
> id	trackByID_node.h	/^                int id;$/;"	m	class:SSDmetric::nodeReqID
> id_front	trackByID.h	/^            int id_front;$/;"	m	class:SSDmetric::trackByID
> idle_time	BTN_waitingTime.h	/^                double idle_time;$/;"	m	class:BTN_Analysis::waiting_time
> insertID	trackByID.h	/^    void trackByID::insertID(int id, int len, uint op){$/;"	f	class:SSDmetric::trackByID
284a369
> isEnd	trackByID_node.h	/^                bool isEnd(){$/;"	f	class:SSDmetric::nodeReqID
286a372
> last_time	BTN_waitingTime.h	/^                double last_time;$/;"	m	class:BTN_Analysis::waiting_time
287a374,375
> lba_offset	trackByID_node.h	/^                int lba_offset;$/;"	m	class:SSDmetric::nodeSubReq
> len	ssd_struct.h	/^    uint            len;$/;"	m	struct:sReadSubResp_t
297a386,395
> module	trackByID_node.h	/^                eModuleType module;$/;"	m	class:SSDmetric::nodeModule
> nodeModule	trackByID_node.h	/^                nodeModule(eModuleType module){$/;"	f	class:SSDmetric::nodeModule
> nodeModule	trackByID_node.h	/^        class nodeModule {$/;"	c	namespace:SSDmetric
> nodeModuleResp	trackByID_node.h	/^                nodeModuleResp(eModuleType module)$/;"	f	class:SSDmetric::nodeModuleResp
> nodeModuleResp	trackByID_node.h	/^        class nodeModuleResp : public nodeModule {$/;"	c	namespace:SSDmetric
> nodeReqID	trackByID_node.h	/^                nodeReqID(int id, int len, CMD_OP op){$/;"	f	class:SSDmetric::nodeReqID
> nodeReqID	trackByID_node.h	/^        class nodeReqID {$/;"	c	namespace:SSDmetric
> nodeSubReq	trackByID_node.h	/^                nodeSubReq(int offset, CMD_OP op){$/;"	f	class:SSDmetric::nodeSubReq
> nodeSubReq	trackByID_node.h	/^        class nodeSubReq{$/;"	c	namespace:SSDmetric
> numSubReq	trackByID_node.h	/^                int numSubReq;$/;"	m	class:SSDmetric::nodeReqID
298a397,398
> op	trackByID_node.h	/^                CMD_OP op;$/;"	m	class:SSDmetric::nodeReqID
> op	trackByID_node.h	/^                CMD_OP op;$/;"	m	class:SSDmetric::nodeSubReq
300a401,402
> printWaitingTime	BTN_waitingTime.h	/^        void waiting_time::printWaitingTime(){$/;"	f	class:BTN_Analysis::waiting_time
> readTimeList	trackByID_node.h	/^                std::vector<nodeModuleResp> readTimeList;$/;"	m	class:SSDmetric::nodeSubReq
301a404
> reqList	trackByID.h	/^            std::deque<nodeReqID> reqList;$/;"	m	class:SSDmetric::trackByID
302a406,416
> respDone	trackByID.h	/^    void trackByID::respDone(int id, int lba_offset, int len, eModuleType module, double time){$/;"	f	class:SSDmetric::trackByID
> respDone	trackByID_node.h	/^                void respDone(double time){$/;"	f	class:SSDmetric::nodeModuleResp
> respDone	trackByID_node.h	/^                void respDone(eModuleType module, double time){$/;"	f	class:SSDmetric::nodeSubReq
> respDone	trackByID_node.h	/^                void respDone(int subID, eModuleType module, double time){$/;"	f	class:SSDmetric::nodeReqID
> respEnd	trackByID_node.h	/^                bool respEnd;$/;"	m	class:SSDmetric::nodeModuleResp
> respFinishTime	trackByID_node.h	/^                double respFinishTime;$/;"	m	class:SSDmetric::nodeModuleResp
> respStart	trackByID.h	/^    void trackByID::respStart(int id, int lba_offset, int len, eModuleType module, double time){$/;"	f	class:SSDmetric::trackByID
> respStart	trackByID_node.h	/^                void respStart(double time){$/;"	f	class:SSDmetric::nodeModuleResp
> respStart	trackByID_node.h	/^                void respStart(eModuleType module, double time){$/;"	f	class:SSDmetric::nodeSubReq
> respStart	trackByID_node.h	/^                void respStart(int subID, eModuleType module, double time){$/;"	f	class:SSDmetric::nodeReqID
> respStartTime	trackByID_node.h	/^                double respStartTime;$/;"	m	class:SSDmetric::nodeModuleResp
305a420
> sIntReq_t	SubReq_def.h	/^   }sIntReq_t;$/;"	t	typeref:struct:sIntReq_t
307d421
< sIntReq_t	SubReq_def.h	/^}sIntReq_t;$/;"	t	typeref:struct:sIntReq_t
315a430,437
> start	BTN_waitingTime.h	/^        void waiting_time::start(){$/;"	f	class:BTN_Analysis::waiting_time
> start	trackByID.h	/^    void trackByID::start(int id, int lba_offset, int len, eModuleType module, double time){$/;"	f	class:SSDmetric::trackByID
> start	trackByID_node.h	/^                void start(double time){$/;"	f	class:SSDmetric::nodeModule
> start	trackByID_node.h	/^                void start(eModuleType module, double time){$/;"	f	class:SSDmetric::nodeSubReq
> start	trackByID_node.h	/^                void start(int subID, eModuleType module, double time){$/;"	f	class:SSDmetric::nodeReqID
> startFlag	BTN_waitingTime.h	/^                bool startFlag;$/;"	m	class:BTN_Analysis::waiting_time
> startTime	trackByID_node.h	/^                double startTime;$/;"	m	class:SSDmetric::nodeModule
> state	BTN_waitingTime.h	/^                eWaitingState state;$/;"	m	class:BTN_Analysis::waiting_time
319a442,444
> trackByID	trackByID.h	/^    class trackByID {$/;"	c	namespace:SSDmetric
> trackByID	trackByID.h	/^    trackByID::trackByID(string const & filename) : fp(filename.c_str(), ios::out){\/\/warning : imported using const from web without understanding, may cause problems (that I can't solve) $/;"	f	class:SSDmetric::trackByID
> transfer_time	BTN_waitingTime.h	/^                double transfer_time;$/;"	m	class:BTN_Analysis::waiting_time
321a447,451
> updateTime	BTN_waitingTime.h	/^        void waiting_time::updateTime(){$/;"	f	class:BTN_Analysis::waiting_time
> waiting_time	BTN_waitingTime.h	/^                waiting_time(){$/;"	f	class:BTN_Analysis::waiting_time
> waiting_time	BTN_waitingTime.h	/^        class waiting_time {$/;"	c	namespace:BTN_Analysis
> writeTimeList	trackByID_node.h	/^                std::vector<nodeModule> writeTimeList;$/;"	m	class:SSDmetric::nodeSubReq
> ~waiting_time	BTN_waitingTime.h	/^                ~waiting_time(){};                $/;"	f	class:BTN_Analysis::waiting_time
diff /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/trackByID.h ./trackByID.h
23,25c23
<             void insertID(int id, int len, uint op); 
<             //Def : A request is initiated, and is entering the device 
<             //Where : at the start of the request, at HOST_IF.h
---
>             void insertID(int id, int LBA, int len, uint op); 
27,38c25
<             void start(int id, int lba_offset, int len, eModuleType module, double time); //todo : accept long length requests
<             //Def : A request has entered the specified module
<             //Where : at a callback function (cmd)
<                                                                                  
<             void done(int id, int lba_offset, int len, eModuleType module, double time);
<             //Def : A request has been issued to the next module
<             //Where : at function write() of a master port
<             
<             void respStart(int id, int lba_offset, int len, eModuleType module, double time);
<             //Def : Response for the specified request has entered the module
<             //Where : at a callback function (data)
<             //Note : reserved for read
---
>             void start(int id, int subLBA, int len, eModuleType module, double time);
40,43c27,29
<             void respDone(int id, int lba_offset, int len, eModuleType module, double time);
<             //Def : Response for the specified request has entered the module
<             //Where : at function write() of a master port
<             //Note : reserved for read
---
>             void track(int id, int subLBA, int len, eModuleType module, double time);
>                                                                                  
>             void done(int id, int subLBA, int len, eModuleType module, double time);
45,48c31
<             void IDFinish(int id);
<             //Def : The request is finished
<             //Where : at HOST_IF.h for a read, at data_queue_thread() in NAND_Manager.h for write
<             //Note : this is where the result is dumped into a file 
---
>             void IDFinish();
60c43
<     void trackByID::insertID(int id, int len, uint op){
---
>     void trackByID::insertID(int id, int LBA, int len, uint op){
62c45
<         this->reqList.push_back(nodeReqID(id, len, (CMD_OP)op));
---
>         this->reqList.push_back(nodeReqID(id, LBA, len, (CMD_OP)op));
68c51
<     void trackByID::start(int id, int lba_offset, int len, eModuleType module, double time){
---
>     void trackByID::start(int id, int subLBA, int len, eModuleType module, double time){
72a56,58
>         int lba_offset = subLBA - this->reqList[index].getLBA();
>         assert( lba_offset >=0);
>         
83c69
<     void trackByID::done(int id, int lba_offset, int len, eModuleType module, double time){
---
>     void trackByID::track(int id, int subLBA, int len, eModuleType module, double time){
86a73,76
>         
>         int lba_offset = subLBA - this->reqList[index].getLBA();
>         assert( lba_offset >=0);
>         
90c80
<             this->reqList[index].done(subID, module, time);
---
>             this->reqList[index].track(subID, module, time);
93,94d82
<     }
< 
96c84,85
<     void trackByID::respStart(int id, int lba_offset, int len, eModuleType module, double time){
---
>     }
>     void trackByID::done(int id, int subLBA, int len, eModuleType module, double time){
100,107c89
<         for(int subID = lba_offset/SECTOR_PER_PAGE; 
<                 subID < (lba_offset + len + SECTOR_PER_PAGE - 1)/SECTOR_PER_PAGE; subID++){
<         
<             this->reqList[index].respStart(subID, module, time);
< 
<         }
<     }
< 
---
>     
109c91,92
<     void trackByID::respDone(int id, int lba_offset, int len, eModuleType module, double time){
---
>         int lba_offset = subLBA - this->reqList[index].getLBA();
>         assert( lba_offset >=0);
111,112c94,95
<         int index = id - this->id_front;
<         assert(index < this->reqList.size());
---
>         assert( !this->reqList[index].isEnd() ); //done is called twice
>  
115,117c98,100
<             
<             this->reqList[index].respDone(subID, module, time);
<     
---
>         
>             this->reqList[index].done(subID, module, time);
> 
122c105
<     void trackByID::IDFinish(int id){
---
>     void trackByID::IDFinish(){
124,127c107,109
< 
< 
<         assert(id - this->id_front < this->reqList.size());
<         this->reqList[id - this->id_front].IDEnd();
---
>         //attempts to dump trace of an ID
>         
>         if(this->reqList.empty()) return;   
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .trackByID.h.swo
Only in ./: .trackByID.h.swp
Binary files /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/.trackByID.h.un~ and ./.trackByID.h.un~ differ
diff /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/trackByID_node.h ./trackByID_node.h
15a16
>         double      g_startTime;
41,42c42,44
<                 double startTime;
<                 double finishTime;
---
>                 double startTime; //at callback
>                 std::vector<double> timings; //track points
>                 double finishTime; //at a request finish in a module
57c59
<                     this->startTime = time;
---
>                     this->startTime = time - g_startTime;
61,73d62
<                 void done(double time){
< 
<                     this->finishTime = time;
<                     this->end = true;
<                 }
<                 virtual void dumptrace(ofstream &fp){
<                     double sendTime = finishTime - startTime; //time spent in module to send request
<                     fp << module << "\t" << sendTime;
<                 }
<         };
< 
< 
<         class nodeModuleResp : public nodeModule {
75c64
<             private : 
---
>                 void track(double time){
77,87c66,67
<                 double respStartTime;
<                 double respFinishTime;
<                 bool respEnd;
< 
<             public :
< 
<                 nodeModuleResp(eModuleType module)
<                 : nodeModule(module){
<                     this->respStartTime = -1;
<                     this->respFinishTime = -1;
<                     this->respEnd = false;
---
>                     this->timings.push_back(time - g_startTime);
>                 
90c70
<                 
---
>                 void done(double time){
92,95c72,75
<                 void respStart(double time){
<                     this->respStartTime = time;
<                 };
<                 void respDone(double time){
---
>                     this->finishTime = time - g_startTime;
>                     this->end = true;
>                 }
>                 void dumptrace(ofstream &fp){
97,107c77,82
<                     this->respFinishTime = time;
<                     this->respEnd = true;
<                 };
< 
<                 void dumptrace (ofstream &fp){
< 
<                     double sendTime = finishTime - startTime; //time spent in module to send request
<                     double respWaitTime = respStartTime - finishTime; //time waiting for the response to come
<                     double respSendTime = respFinishTime - respStartTime; // time spent in module to complete response
<                     double respTime = respFinishTime - startTime; //total response time in module
<                     fp << module << "\t" << sendTime << "\t" << respWaitTime << "\t" << respSendTime << "\t" << respTime;
---
>                     //just going to use time stamp for now
>                     fp << module << "\t" << startTime;
>                     for(int i=0; i < this->timings.size(); i++) fp << "\t" << this->timings[i];
>                     fp << "\t" << finishTime;
>                 
>                 
109d83
< 
113a88,89
> 
> 
119,120c95
<                 std::vector<nodeModule> writeTimeList;
<                 std::vector<nodeModuleResp> readTimeList;
---
>                 std::vector<nodeModule> TimeList;
127,133d101
<                     if(op == CMD_WRITE){
< 
<                         this->writeTimeList.reserve(NUM_MODULES);
<                         for(int i=0; i<NUM_MODULES; i++){
<                             this->writeTimeList.push_back(nodeModule((eModuleType) i));
<                         } 
< 
135,144c103,106
<                     }
<                     else if(op == CMD_READ){
<                     
<                         this->readTimeList.reserve(NUM_MODULES);
<                         for(int i=0; i<NUM_MODULES; i++){
<                             this->readTimeList.push_back(nodeModuleResp((eModuleType) i));
<                         } 
<                     
<                     
<                     }
---
>                     this->TimeList.reserve(NUM_MODULES);
>                     for(int i=0; i<NUM_MODULES; i++){
>                         this->TimeList.push_back(nodeModule((eModuleType) i));
>                     } 
153,160c115,116
<                     if(this->op == CMD_WRITE){     
<                         assert((int)module < this->writeTimeList.size());
<                         this->writeTimeList[(int)module].start(time);
<                     }
<                     else if(this->op == CMD_READ){     
<                         assert((int)module < this->readTimeList.size());
<                         this->readTimeList[(int)module].start(time);
<                     }
---
>                     assert((int)module < this->TimeList.size());
>                     this->TimeList[(int)module].start(time);
164,178c120
<                 void done(eModuleType module, double time){
< 
<                     if(this->op == CMD_WRITE) {
<                         
<                         assert((int)module < this->writeTimeList.size());
<                         this->writeTimeList[module].done(time);//insert time
<                     }
<                     else if(this->op == CMD_READ){
<                         assert((int)module < this->readTimeList.size());
<                         this->readTimeList[module].done(time);//insert time
<                     }
< 
<                 }
< 
<                 void respStart(eModuleType module, double time){
---
>                 void track(eModuleType module, double time){
180,181c122,123
<                     assert((int)module < this->readTimeList.size());
<                     this->readTimeList[module].respStart(time);
---
>                     assert((int)module < this->TimeList.size());
>                     this->TimeList[(int)module].track(time);
183a126
>                 void done(eModuleType module, double time){
185c128,129
<                 void respDone(eModuleType module, double time){
---
>                     assert((int)module < this->TimeList.size());
>                     this->TimeList[module].done(time);//insert time
187,188d130
<                     assert((int)module < this->readTimeList.size());
<                     this->readTimeList[module].respDone(time);//insert time
190a133
> 
192c135
<                 
---
> 
196,203c139,140
<                         if(this->op == CMD_WRITE) {
<                             assert(i < this->writeTimeList.size());
<                             this->writeTimeList[i].dumptrace(fp);
<                         }
<                         else if(this->op == CMD_READ) {
<                             assert(i < this->readTimeList.size());
<                             this->readTimeList[i].dumptrace(fp);
<                         }
---
>                         assert(i < this->TimeList.size());
>                         this->TimeList[i].dumptrace(fp);
208c145
<                 
---
> 
220a158
>                 int LBA;
224c162
<                 bool end;
---
>                 unsigned long long int completeReqFlags; //consider this as group of flags
229c167
<                 nodeReqID(int id, int len, CMD_OP op){
---
>                 nodeReqID(int id, int LBA, int len, CMD_OP op){
233c171
< 
---
>                     this->LBA = LBA;
235a174
>                     this->op = op;
241c180
<                     this->end = false;
---
>                     this->completeReqFlags = 0;
259,265d197
<                 void done(int subID, eModuleType module, double time){
<                     
<                     assert(subID < this->SubList.size());
<                     this->SubList[subID].done(module, time);
<                     
<                     
<                 };
267,268c199
< 
<                 void respStart(int subID, eModuleType module, double time){
---
>                 void track(int subID, eModuleType module, double time){
271c202
<                     this->SubList[subID].respStart(module, time); 
---
>                     this->SubList[subID].track(module, time); 
276c207,208
<                 void respDone(int subID, eModuleType module, double time){
---
> 
>                 void done(int subID, eModuleType module, double time){
279,280c211,212
<                     this->SubList[subID].respDone(module, time);
<                     
---
>                     assert(subID < this->numSubReq);
>                     this->SubList[subID].done(module, time);
281a214,217
>                     if ((this->op == CMD_WRITE)&&(module == NAND_Manager)){ //write is done when it's finished on NAND
>                         assert(subID < 64); //to prevent integer overflow
>                         this->completeReqFlags |= 1 << subID; 
>                     }
283a220
> 
301,304d237
<                 void IDEnd(){
<                     
<                     this->end = true;
<                 }
308c241,245
<                     return this->end;
---
>                     return (this->completeReqFlags + 1 == (1 << this->numSubReq));
>                 }
> 
>                 int getLBA(){
>                     return this->LBA;
309a247
> 
Only in /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/: .trackByID_node.h.swp
Binary files /home/xoqhd1212/hynix_SSD/20180509/lib/src/header/.trackByID_node.h.un~ and ./.trackByID_node.h.un~ differ

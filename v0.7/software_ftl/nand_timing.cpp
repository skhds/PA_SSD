
/*
*
*		OpAnalyzer.cpp
*		generated by Gun, written by rab*
*		member functions for class COpAnalyzer, commented complete
*
*/

#include "nand_timing.h"

extern "C"{
#include "ftl_utils.h"
};

using namespace std;

COpAnalyzer::COpAnalyzer(){

	spec.iChannelCount = NAND_ARRAY_CHANNEL;
	spec.iWayCount = NAND_ARRAY_WAY;

	spec.iPlanePerDev = NAND_PLANE_PER_WAY;
	spec.iBlockPerPlane = NAND_BLOCK_PER_PLANE;
	spec.iPagePerBlock = NAND_PAGE_PER_BLOCK;
	spec.iPageSize = NAND_PAGE_BYTE;

	computeSpecBitWidth(&spec);

	spec.tPROG = NAND_TIMING_TPROG;
	spec.tR = NAND_TIMING_TR;
	spec.tWC = NAND_TIMING_TWC;
	spec.tRC = NAND_TIMING_TRC;
	spec.tBER = NAND_TIMING_TBER;

	initTimings();
	//COpAnalyzer(spec);

}

void COpAnalyzer::initTimings(){
	tPROG = (double)spec.tPROG / 1000;
	tR = (double)spec.tR / 1000;
	tWC = (double)spec.tWC / 1000;
	tRC = (double)spec.tRC / 1000;
	tBER = (double)spec.tBER / 1000;

	BLOCK = spec.iBlockPerPlane;
	CHANNEL = spec.iChannelCount;
	WAY = spec.iWayCount;
	SECTOR = spec.iPageSize / 512;

	for(int i=0; i < NAND_CMD_TYPE_CNT ; i++){
		iNumCmdCnt[i] = 0;
	}

	this->m_IncomeOpList = new CQueueInt;
	this->NANDs = new SNANDchannel[CHANNEL];
	for(uint i=0; i < CHANNEL ; i++)
	{
		this->NANDs[i].way = new SNANDway[WAY];
		this->NANDs[i].wayOp = new COpQ[WAY];
	}

	this->iErCnt = new uint**[CHANNEL];
	for(uint i=0; i < CHANNEL ; i++)
	{
		this->iErCnt[i] = new uint*[WAY];
		for(uint j=0 ; j < WAY ; j++)
		{
			this->iErCnt[i][j] = new uint[BLOCK];
			memset(this->iErCnt[i][j], 0x00, sizeof(uint) * BLOCK);
		}
	}


	this->SetZeroTime();

}

COpAnalyzer::COpAnalyzer(sNandSpec spec_)
	:spec(spec_),
	tPROG((double)spec_.tPROG/1000),
	tR((double)spec_.tR/1000),
	tWC((double)spec_.tWC/1000),
	tRC((double)spec_.tRC/1000),
	tBER((double)spec_.tBER/1000)
{
	BLOCK = spec.iBlockPerPlane;
	CHANNEL = spec.iChannelCount;
	WAY = spec.iWayCount;
	SECTOR = spec.iPageSize / 512;

	for(int i=0; i < NAND_CMD_TYPE_CNT ; i++){
		iNumCmdCnt[i] = 0;
	}

	this->m_IncomeOpList = new CQueueInt;
	this->NANDs = new SNANDchannel[CHANNEL];
	for(uint i=0; i < CHANNEL ; i++)
	{
		this->NANDs[i].way = new SNANDway[WAY];
		this->NANDs[i].wayOp = new COpQ[WAY];
	}

	this->iErCnt = new uint**[CHANNEL];
	for(uint i=0; i < CHANNEL ; i++)
	{
		this->iErCnt[i] = new uint*[WAY];
		for(uint j=0 ; j < WAY ; j++)
		{
			this->iErCnt[i][j] = new uint[BLOCK];
			memset(this->iErCnt[i][j], 0x00, sizeof(uint) * BLOCK);
		}
	}
	

	this->SetZeroTime();
}

COpAnalyzer::		// Destructor
~COpAnalyzer()
{	
	delete m_IncomeOpList;
	delete [] this->NANDs;
}


double COpAnalyzer::	
OpComputeCHTime(int iCh)
{

	double latestReadyTime = 0;
	SNANDchannel *current = &(NANDs[iCh]);
	//bool allEmpty = OpAllWayEmpty(*current);	// If there is no operation for any way.
	SSmallOp temp;
	char empty = 0x0;

	for(uint i=0 ; i < WAY ; i++){
		if(current->wayOp[i].empty()) 
			empty = (empty | (1 << i));
	}


	while(empty != ((1 << WAY)-1)){
		for(uint i=0; i < WAY ; i++){

			if(!(current->wayOp[i].empty())){
				temp = OpGetSmallOpNPop(&(current->wayOp[i]));		// get op and remove it from queue.
				switch(temp.type){	
			case takeBus:						// if it takes BUS

				current->nextBusEnable = 
					(current->nextBusEnable > current->way[i].nextReady) ? 
					current->nextBusEnable + temp.time : 
				current->way[i].nextReady + temp.time;

				current->way[i].nextReady = current->nextBusEnable;

				//current->nextBusEnable += temp.time;					// bus enable increased
				//current->way[i].nextReady += current->nextBusEnable;	// device will be ready after this.

				break;

			case takeDevice:

				current->way[i].nextReady += temp.time;					// device will be ready after this, not BUS

				break;
				}

#ifdef __OPANALYZER_DEBUG__
				if(current->nextBusEnable > current->way[i].nextReady)
					cout << "Bus should be ready !!" << endl;
#endif

				if(latestReadyTime < current->way[i].nextReady)
					latestReadyTime = current->way[i].nextReady;

				if(latestReadyTime < current->nextBusEnable)
					latestReadyTime = current->nextBusEnable;			// Pick latest time.


				if(current->wayOp[i].empty()) 
					empty = (empty | (1 << i));

			}	
		}

		//allEmpty = allEmpty & current->wayOp[i].empty();
		//allEmpty = OpAllWayEmpty(*current);
		
	};						// if there is any operation, do it until everything is disappeared.

	latestReadyTime = (latestReadyTime > current->nextBusEnable) ? latestReadyTime : current->nextBusEnable;
	// pick latest one.

	return latestReadyTime;		// return required time for the channel
}

void COpAnalyzer::	
SetZeroTime()
{	
	for(uint i=0; i < CHANNEL ; i++){
		for(uint j=0 ; j < WAY ; j++){
			NANDs[i].way[j].nextReady = 0;		
		}
		NANDs[i].nextBusEnable = 0;
	}
}		// every time line is set to 0


void COpAnalyzer::	
OpCOpQPush(COpQ *smallQ, double time, SmallOpType type)		// push values to queue
{
	SSmallOp temp;
	temp.time = time;
	temp.type = type;
	smallQ->push(temp);
}

bool COpAnalyzer::	
OpAllWayEmpty(SNANDchannel Ch)			// return true if all Op queues of a channel are empty.
{
	
	bool temp = true;

	for(uint i=0; i < WAY ; i++)
		temp = temp & Ch.wayOp[i].empty();

	return temp;

}

SSmallOp COpAnalyzer::	
OpGetSmallOpNPop(COpQ *wayOp)			// just get and pop
{
	SSmallOp temp = wayOp->front();
	wayOp->pop();
	return temp;
}

inline void COpAnalyzer::			
increaseErCnt(int iCh, int iWy, int iBk)		// increase the erase count.
{
	iErCnt[iCh][iWy][iBk]++;
}


unsigned long long int
COpAnalyzer::computeTime(std::list<sNandCmd> ftlCmd)
{
	SLargeOp op, opDes;
	double *elapsedTime = new double[CHANNEL];				
	double maxTime = 0;
	std::list<sNandCmd>::iterator iter;

	// init time
	SetZeroTime();


	for(iter = ftlCmd.begin() ; iter != ftlCmd.end() ; iter++)
	{
		op.iOp = this->cmdDecode(iter->op);

		if(op.iOp == NAND_CBR_PAGE)
		{
			opDes.iOp = NAND_CBR_PAGE;
			this->srcAddrDecode(opDes, *iter);
			this->OpSeparate(opDes);
			//m_LargeOpList->push(opDes);
			op.iOp = NAND_CBW_PAGE;
		}

		this->addrDecode(op, *iter);
		this->OpSeparate(op);
	}

	for(uint i=0 ; i < CHANNEL ; i++){
		elapsedTime[i] = OpComputeCHTime(i);	// compute time for each channel

		//cout << i << endl;

		if(elapsedTime[i] > maxTime){
			maxTime = elapsedTime[i];			// pick max one.
		}
	}

	delete [] elapsedTime;

	return (unsigned long)maxTime;	
}

void
COpAnalyzer::srcAddrDecode(SLargeOp &largeOp, sNandCmd cmd)
{
	largeOp.iCh = cmd.src.iChannel;
	largeOp.iWy = cmd.src.iWay;
	largeOp.iBk = cmd.src.iBlk;
	largeOp.iPg = cmd.src.iPage;
}

void
COpAnalyzer::addrDecode(SLargeOp &largeOp, sNandCmd cmd)
{
	largeOp.iCh = cmd.dest.iChannel;
	largeOp.iWy = cmd.dest.iWay;
	largeOp.iBk = cmd.dest.iBlk;
	largeOp.iPg = cmd.dest.iPage;
}

unsigned int
COpAnalyzer::cmdDecode(eNandOp op)
{

	iNumCmdCnt[op]++;

	switch(op)
	{
	case NAND_CMD_PROGRAM:
	case NAND_CMD_MAP_PROGRAM:
		return NAND_PGM_PAGE;
		break;
	case NAND_CMD_READ:
	case NAND_CMD_RNM_READ:
	case NAND_CMD_MAP_READ:
		return NAND_READ_PAGE;
		break;
	case NAND_CMD_COPYBACK_W:
		return NAND_CBW_PAGE;
		break;
	case NAND_CMD_COPYBACK:
	case NAND_CMD_COPYBACK_R:
	case NAND_CMD_MAP_COPYBACK:
		return NAND_CBR_PAGE;
		break;
	case NAND_CMD_ERASE:
	case NAND_CMD_MAP_ERASE:
		return NAND_ERASE;
		break;
	default:
		cout << "No proper command !" << endl;
		getchar();
		exit(1);
		break;
	}

	return 0;
}

void COpAnalyzer::
OpSeparate(SLargeOp op)
{
	COpQ *smallQ;
	smallQ = &(NANDs[op.iCh].wayOp[op.iWy]);

	switch(op.iOp){
	case NAND_PGM_PAGE:			// program : tCMD + tTRANS + (tPROG)

		//this->essenOp->push(iOp);
		OpCOpQPush(smallQ, tWC * (SECTOR * 512 + 7), takeBus);
		OpCOpQPush(smallQ, tPROG, takeDevice);

		break;

	case NAND_READ_PAGE:			// read : tCMD + (tR) + tTRANS

		//this->essenOp->push(iOp);
		OpCOpQPush(smallQ, tWC * 7, takeBus);
		OpCOpQPush(smallQ, tR, takeDevice);
		OpCOpQPush(smallQ, tWC * (SECTOR * 512), takeBus);			

		break;

	case NAND_ERASE:			// erase : tCMD + (tBER)

		OpCOpQPush(smallQ, tWC * 7, takeBus);
		OpCOpQPush(smallQ, tBER, takeDevice);
		increaseErCnt(op.iCh, op.iWy, op.iBk);

		break;

	case NAND_CBR_PAGE:		// copyback_read : tCMD + (tR)

		OpCOpQPush(smallQ, tWC * 7, takeBus);
		OpCOpQPush(smallQ, tR, takeDevice);

		break;

	case NAND_CBW_PAGE:		// copyback_write : tCMD + (tPROG)

		OpCOpQPush(smallQ, tWC * 7, takeBus);
		OpCOpQPush(smallQ, tPROG, takeDevice);

		break;

	default:

		cout << "OpAnalyzer :: Fail to separate op." << endl;

		break;
	}

}
